"""
ANPTOP Backend - Exploitation Endpoints
"""

from datetime import datetime
from typing import Optional, List
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from pydantic import BaseModel

from app.db.session import get_db
from app.core.security import get_current_user
from app.models.user import User

router = APIRouter()


# Pydantic schemas
class ExploitCandidateCreate(BaseModel):
    """Exploit candidate creation schema."""
    vulnerability_id: int
    host_id: int
    host_ip: str
    cve_id: Optional[str] = None
    cvss_score: float
    severity_rating: str
    exploit_available: bool
    exploit_modules: List[str] = []
    recommendation: str
    priority: int = 1


class ExploitCandidateResponse(BaseModel):
    """Exploit candidate response schema."""
    id: int
    vulnerability_id: int
    host_id: int
    host_ip: str
    cve_id: Optional[str]
    cvss_score: float
    severity_rating: str
    exploit_available: bool
    exploit_modules: List[str]
    recommendation: str
    priority: int
    status: str
    created_at: datetime


class ExploitExecutionCreate(BaseModel):
    """Exploit execution creation schema."""
    engagement_id: int
    vulnerability_id: int
    exploit_module: Optional[str] = None
    target_ip: str
    target_port: Optional[int] = None
    status: str = "pending"


class ExploitExecutionResponse(BaseModel):
    """Exploit execution response schema."""
    id: int
    engagement_id: int
    vulnerability_id: int
    exploit_module: Optional[str]
    target_ip: str
    target_port: Optional[int]
    status: str
    success: Optional[bool] = None
    session_id: Optional[str] = None
    session_type: Optional[str] = None
    output: Optional[str] = None
    error_message: Optional[str] = None
    executed_by: Optional[str] = None
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None


# In-memory storage for demo (use database in production)
exploit_candidates = []
exploit_executions = []


@router.post("/candidates", response_model=ExploitCandidateResponse)
async def create_exploit_candidate(
    candidate: ExploitCandidateCreate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    Create a new exploit candidate for tracking.
    """
    new_candidate = {
        'id': len(exploit_candidates) + 1,
        **candidate.dict(),
        'status': 'pending',
        'created_at': datetime.utcnow(),
    }
    exploit_candidates.append(new_candidate)
    return new_candidate


@router.get("/candidates", response_model=List[ExploitCandidateResponse])
async def get_exploit_candidates(
    engagement_id: Optional[int] = None,
    severity: Optional[str] = None,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    Get exploit candidates, optionally filtered by engagement or severity.
    """
    candidates = exploit_candidates
    
    if engagement_id:
        # Filter by engagement (would need engagement_id field)
        pass
    
    if severity:
        candidates = [c for c in candidates if c['severity_rating'] == severity]
    
    return candidates


@router.post("/execute", response_model=ExploitExecutionResponse)
async def create_exploit_execution(
    execution: ExploitExecutionCreate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    Create a new exploit execution record.
    """
    new_execution = {
        'id': len(exploit_executions) + 1,
        **execution.dict(),
        'success': None,
        'session_id': None,
        'session_type': None,
        'output': None,
        'error_message': None,
        'executed_by': current_user.email if current_user else None,
        'started_at': datetime.utcnow(),
        'completed_at': None,
    }
    exploit_executions.append(new_execution)
    return new_execution


@router.put("/execute/{execution_id}", response_model=ExploitExecutionResponse)
async def update_exploit_execution(
    execution_id: int,
    status: Optional[str] = None,
    success: Optional[bool] = None,
    session_id: Optional[str] = None,
    session_type: Optional[str] = None,
    output: Optional[str] = None,
    error_message: Optional[str] = None,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    Update an exploit execution record.
    """
    execution = next((e for e in exploit_executions if e['id'] == execution_id), None)
    
    if not execution:
        raise HTTPException(status_code=404, detail="Exploit execution not found")
    
    if status:
        execution['status'] = status
    if success is not None:
        execution['success'] = success
    if session_id:
        execution['session_id'] = session_id
    if session_type:
        execution['session_type'] = session_type
    if output:
        execution['output'] = output
    if error_message:
        execution['error_message'] = error_message
    
    if status == 'completed':
        execution['completed_at'] = datetime.utcnow()
    
    return execution


@router.get("/execute/{execution_id}", response_model=ExploitExecutionResponse)
async def get_exploit_execution(
    execution_id: int,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    Get details of a specific exploit execution.
    """
    execution = next((e for e in exploit_executions if e['id'] == execution_id), None)
    
    if not execution:
        raise HTTPException(status_code=404, detail="Exploit execution not found")
    
    return execution


@router.get("/sessions")
async def get_active_sessions(
    engagement_id: Optional[int] = None,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    Get active exploit sessions.
    """
    sessions = [
        e for e in exploit_executions 
        if e['status'] == 'completed' and e.get('success') == True
    ]
    
    return {
        'active_sessions': len(sessions),
        'sessions': sessions,
    }
